{1, 0, 0, 0}
{1, 1, 0, 0}
{0, 1, 0, 0}
{0, 1, 1, 1}

ratInMaze(arr, int x1, int y1, int x2, int y2){
   if(x1 == x2 && y1 == y2)
      return 1;
   if(x1 < 0 || y1 < 0 || x1 > x2 || y1 > y2 || !arr[x][y])
      return;
   bool canReachEnd = ratInMaze(arr,x1+1,y1,x2,y2) || ratInMaze(arr,x1,y1+1,x2,y2) || ratInMaze(arr,x1-1,y1,x2,y2) || ratInMaze(arr,x1,y1-1,x2,y2)
   return canReachEnd;
}

struct Node {
  int value;
  Node* left, *right;
  Node(int data){
   this->value = data;
   this->left = NULL;
   this->right = NULL; 
 }
}

int findHeightOfTree(Node* root){
  if(root == NULL)
     return 0;
   return 1 + max(findHeightOfTree(root->left),findHeightOfTree(root->right));
}

           1
          / \
         2   5
        /
       3       
        \
         4


Node* deleteNodeFromBinaryTrees(node* root, int key){
  if(root == NULL)
     return NULL;
  if(key < root->key)
    root->left = deleteNodeFromBinaryTrees(root->left, key)
  
  if(key > root->key)
    root->right = deleteNodeFromBinaryTrees(root->right, key)

}


1,2,3,4,5,7

bool IsCBT(Node* root, int index, int count) {
 if(root == NULL)
    return true;
 // this condition checks if the tree node only has right child but no left child
 if(index >= count)
    return false;
 return IsCBT(root->left,2*index+1,count) && IsCBT(root->right, 2*index+2,count)
}


bool IsMinHeap(Node* root){
  if(!root)
    return true;
  else if(!root->right)
    return root->left->value > root->value;
  else {
    return root->value < root->left->value && root->value < root->right->value && IsMinHeap(root->left) && IsMinHeap(root->right)
  }
}

// this is for max heap
void heapify(vector<int> elements, int index, int size) {
  int largest = index;
  int leftIndex = 2*index+1;
  int rightIndex = 2*index+2;
  largest = leftIndex < size && elements[leftIndex] > elements[largest] ? leftIndex : index;
  largest = rightIndex < size && elements[rightIndex] > elements[largest] ? rightIndex : index; 
  // means not heapified  
  if(largest != index) {
    swap(elements[index], elements[largest]);
    heapify(elements, largest, size)      
  }
}

void buildHeap(){
 // we only need to heapify the tree with nodes as leaf nodes are already heapified
 int startIndex = elements.size()-1/2;
 for(int index = startIndex; index > -1; index--){
    heapify(elements, index, size)
 }
}

void heapSort(vector<int>& elements){
 // as first elment is already sorted
 for(int endIndex = size()-1; endIndex > 0; endIndex--){
      swap(elements[endIndex], elements[0]);
      // heapify all the elments other than the last one
      heapify(elements, endIndex - 1, size())
 }
}

void sortUsingInorderTraversal(Node* root, vector& elements){
  if(!root)
     return;
  sortUsingInorderTraversal(root->left);
  elements.push_back(root->value);
  sortUsingInorderTraversal(root->right);
}

void checkCBTUsingLevelOrderTraversal(Node *root){
 if(!root)
   return true;
 // only root is present
 if(!root->left && !root->right)
   return true;
 queue<Node*> q;
 q.push(root);
 while(!q.empty()){
  Node* current = q.front();
  if(current->right && !current->left)
    return false;
  else if(current->left && !current->right)
    q.push(current->left)
  else
    q.push(current->left);
    q.push(current->right);
 }
 // traversed the whole tree every node has atleast 2 or 1 left child
 return true;
}

Q. convert BST to minheap such that Node->value < LeftNode->value < RightNode->value 
A. store inorder traversal into a vector and than replace values of node by doing preorder traversal;
void constructTreeUsingPreOrder(Node *root,vector<int> elements, int index){
  if(!root)
    return;
  root->value = elements.at(0);
  elements.erase(elements.begin(),0);
  constructTreeUsingPreOrder(root->left, elements, index+1);
  constructTreeUsingPreOrder(root->right, elements, index+1);
}

// Merge K-Sorted arrays
void MergeKSortedArrays(vector<vector<int>> arrays, vector<int>& newArray){
 priority_queue<int, vector<int>, greater<int>> pq;
 for(auto subArray : arrays){
    for(int element: subArray){
        pq.push(element);
    }
  }
 
  while(!pq.empty()){
     newArray.push_back(pq.top());
     pq.pop();
 }
}


// as all the linked lists are sorted so their minimum element will be at index 0 and next minimum after that and so on

 
Node* mergeKSortedLinkedLists(vector<Node*> sortedLinkedLists){
  int countOfLinkedLists = sortedLinkedLists.size();
  if(!countOfLinkedLists) return NULL;
  auto compare = [](Node* a, Node* b) { return a->data < b->data ; }
  priority_queue<Node*, vector<Node*>, decltype(compare)> pq(compare);
  for(Node* node: sortedLinkedLists)
      pq.push(node);
  Node* head = pq.top();
  Node* tail = head;
  pq.pop();
  Node* top = NULL;
  while(!pq.empty()){
    top = pq.top();
    tail->next = top;
    tail = tail->next;
    if(top->next)
       pq.push(top->next);
    pq.pop();
 }
  return head;
}


a[] = {20, -5, -1}, K = 3
void KthLargestSumSubArray(vector<int> a, k){
   priority_queue<int> pq;
   int sum = 0, max_so_far = 0;
   
  for(int index = 0; index < a.size(); index++){ 
     sum = a[index];
     max_so_far = 0;
     for(int innerIndex = index + 1; innerIndex < a.size(); innerIndex++){
          sum += a[innerIndex];
          max_so_far = max(max_so_far, sum);
     }
     //(O)nlogn - to get the top, as it will heapify each and every time the element is pushed  
     pq.push(a[index]);
     pq.push(max_so_far);  
   }
  
  int count = k - 1 // when k = 3 we need to remove 2 elements to get the 3rd largest sum;
  while(count) {
      pq.pop();
  }
  return pq.top(); 
}


// string is balanced if no 'b' appears before 'a' -> ababb -> aabb therefore number of deletions = 1, i.e remove b from 1 index
or we can delete a at index 2.
void numberOfDeletionsToMakeStringBalanced(string str){
  int char_to_be_removed = 0;
  if(str.length() == 0 || str.length() == 1)
     return char_to_be_removed;
  stack<char> st;
  string balancedString = "";
  for(int index = 0; index < str.length(); str++){
       if(!st.empty() && st.top() == 'b' && str[index] == 'a')
         st.pop();
         char_to_be_removed++;
       else
          balancedString.push_back(str[index]);
          st.push(str[index]);
  }
   return char_to_be_removed;
}

bool IsSafeMove(int row, int column, vector<vector<int>> maze, vector<vector<bool>> visited) {
  return maze[row][column] == 1 && visited[row][column] == 1;
}

string getNextMove(int currentRow, int currentColumn, int nextRow, int nextColumn) {
   if(currentRow < nextRow)
      return "D";
   else if(currenColumn < nextColumn)
      return "R";
   else if(currentRow > nextRow)
      return "U";
   return "L"
}

void ratInMazeUsingBackTracking(vector<vector<int>> maze, int row, int column, string& direction, vector<string>& result, vector<vector<int>>& visited, vector<int> xDirection, vector<int>, yDirection){
  if(row < 0 || column < 0 || row == maze.length() || column == maze[0].length())
     return;
  if(row == maze.length()-1 && column == maze[0].length()-1){
     result.push_back(direction)
     return;
  }
  visited[row][column] = 1;
  for(int index = 0; index < 4; index++) {
     int nextRow = row + xDirection[index];
     int nextColumn =  column + yDirection[index]
     if(IsSafeMove(nextRow, nextColumn, maze, visited)){
          direction.push_back(getNextMove(row, column, nextRow, nextColumn));
          ratInMazeUsingBackTracking(maze, nextRow, nextColumn, direction, result, visited, xDirection, yDirection);
          direction.pop_back();   
    }
  }
  visited[row][column] = 0;
}

vector<string> getDirectionForRatToReachEndOfMaze(){
  vector<vector<int>> maze = {
      {1,0,0,0},
      {1,1,0,1},
      {1,1,0,0},
      {0,1,1,1}
  };
  vector<vector<int>> visited = {
    {0, 0,0 ,0},
    {0, 0,0 ,0},
    {0, 0,0 ,0},
    {0, 0,0 ,0}
 };
 vector<int> xDirection = {1, 0, -1, 0}; 
 vector<int> yDirection = {0, 1, 0, -1};
 vector<string> result;
 ratInMazeUsingBackTracking(maze, 0, 0, "", result, visited,xDirection, yDirection);
 return result;
}

bool IsThereAQueenOnTheTopLeftDiagonals(int row, int column,int size, vector<vector<string>> chessBoard){
  if(row < 0 || column < 0)
     return false;
  if(chessBoard[row][column] == "Q")
     return true;
  return IsThereAQueenOnTheTopLeftDiagonals(row - 1, column - 1, size, chessBoard);        
}

bool IsThereAQueenOnTheBottomLeftDiagonals(int row, int column,int size, vector<vector<string>> chessBoard){
  if(row > size || column < 0)
     return false;
  if(chessBoard[row][column] == "Q")
     return true;
  return IsThereAQueenOnTheBottomLeftDiagonals(row + 1, column - 1, size, chessBoard);        
}

/** This will do search in (O)N time complexity whereas we can optimise that by using hashmap we can
    check for that by using a hashmap, for example if we have stored value in the 2nd row we can store value
    in presenceAtRows hashmap so that when placing queen in same row of different column we don't have to check all the columns
    from 0 till currentColumn-1, same with top left diagonal if we fill our matrix with the formulae
    chessBoard[row][column] = (n-1 + (column-row)), we can see that values on the top left of (3,3) i.e (2,2), (1,1), (0,0) will        have the same values, and then we can store values in the presenceAtTopLeftDiagonals hashmap, in the similar fashion we can         store values for the bottom left using  chessBoard[row][column] = (column + row) inside the presenceAtBottomLeftDiagonals     hashmap, check optimisedSearchOfChessBoard for implementation.
**/
bool IsSafeToPutQueen(int currentRow, int currentColumn, vector<vector<string>> chessBoard){

 vector<int> xDiagnol = {-1, 1, 1, -1}
 vector<int> yDiagonal = {-1, 1, -1, 1}
 /** check for column **/
 for(int row = 0; row < currentRow; row++)
     if(chessBoard[row][currentColumn] == "Q")
        return false;
 /** check for row **/
 for(int column = 0; column < currentColumn; column++)
     if(chessBoard[currentRow][column] == "Q")
        return false;
 return !IsThereAQueenOnTheTopLeftDiagonals(row, column, size, chessBoard) && !IsThereAQueenOnTheBottomLeftDiagonals(row, column, size, chessBoard);
}

bool optimisedSearchOfChessBoard(map<int, bool> presenceAtRows, map<int, bool> presenceAtTopLeftDiagonals, map<int, bool> 				presenceAtBottomLeftDiagonals, int key) {
    return (presenceAtRows.find(key) == presenceAtRows.end() ) &&
           (presenceAtTopLeftDiagonals.find(key) == presenceAtTopLeftDiagonals.end()) &&
           (presenceAtBottomLeftDiagonals.find(key) == presenceAtBottomLeftDiagonals.end());
}

void PlaceNQueensOnChessBoard(vector<vector<string>>& chessBoard,int currentColumn, int& totalWays,map<int, bool> presenceAtRows, 			     map<int, bool> presenceAtTopLeftDiagonals,map<int, bool> presenceAtBottomLeftDiagonals){
    if(currentColumn > chessBoard.length() - 1)
      return;
    if(currentColumn == chessBoard.length()){
       totalWays++;
       return;
    }
    int size = chessBoard.size();
    for(int row = 0; row < chessBoard.length(); row++) {
       /** O(N) search
        if(IsSafeToPutQueen(row, currentColumn, chessBoard)) {
            chessBoard[row][currentColumn] = "Q";
            PlaceNQueensOnChessBoard(chessBoard,currentColumn + 1,totalWays);
            chessBoard[row][currentColumn] = "E";
        }
       **/

        if(optimisedSearchOfChessBoard()) {
            presenceAtRows.insert({ row, true });
            presenceAtTopLeftDiagonals({size - row + (currentColumn - row) , true });
            presenceAtBottomLeftDiagonals({ column + row, true });
            PlaceNQueensOnChessBoard(chessBoard,currentColumn + 1,totalWays, presenceAtRows, presenceAtTopLeftDiagonals, presenceAtBottomLeftDiagonals);
            presenceAtRows.erase(row);
            presenceAtTopLeftDiagonals.erase(size - row + (currentColumn - row));
            presenceAtBottomLeftDiagonals.erase(column + row);
        }
    }
}

int numberOfWaysToPutNQueensOnChessBoard(){
   vector<vector<string>> chessBoard(5,vector<string>(5,"E"));
   int totalWays = 0;
   map<int, bool> presenceAtRows;
   map<int, bool> presenceAtTopLeftDiagonals;
   map<int, bool> presenceAtBottomLeftDiagonals;
   PlaceNQueensOnChessBoard(chessBoard,0,totalWays, presenceAtRows, presenceAtTopLeftDiagonals, presenceAtBottomLeftDiagonals);
   return totalWays;
}


bool IsThisBestChoice(int number, map<int, bool> rowMap,
                 map<int, bool> columnMap,int row, int column){
  bool IsNumberInSubGrid = false;
  /** check in sub-grid 3x3 **/
  return (rowMap.find(number) == rowMap.end()) && (columnMap.find(number) == columnMap.end()) && !IsNumberInSubGrid;
   
}

bool solveSudoku(vector<vector<int>>& sudoku, int size,map<int, bool> rowMap, map<int, bool> columnMap){
   for(int row = 0; row < size; row++){
       for(int column = 0; column < size; column++){
            if(sudoku[row][column] == 0){
              for(int number = 1; number < 10; number++){
                   if(IsThisBestChoice(number,rowMap,columnMap,currentRow,currentColumn)) {
                      rowMap[number] = 1;
                      columnMap[number] = 1;
		      sudoku[row][column] = number;
                      bool furtherSolutionPossible = solveSudoku(sudoku, size, rowMap, columnMap);
                      if(!furtherSolutionPossible) {
                          rowMap.erase(number);
                      	  columnMap.erase(number);
		      	  sudoku[row][column] = 0;
                      }
                      else
                        return furtherSolutionPossible;
		   }
             	}		
            }
            return false; // we have tried every number from 1-9 and none of them returns true;
        }
     }
   return true;
}

/** str = "abbzxxy -> azy O(N) "**/
string removeAllAdjacentDuplicates(string str){
 string output = "";
 if(str.length() == 0)
    return output;
 output.push_back(str[0]);
 for(int index = 1;index < str.length();index++){
   if(str[index] == str[index-1])
      output.pop_back();
   else
     output.push_back(str[index]);
 }
 return output;
}

bool IsSafeToChooseThisColour(int colour, vector<vector<int>> graph, vector<pair<int, int>>& colours, int currentVertex){
     for(int vertex = 0; vertex < graph[0].size(); vertex++){
         if(graph[currentVertex][vertex] == 1 && colours.find(make_pair({vertex, colour})) != colours.end())
            return 0;
     }
    return 1;
}

bool mColouringProblem(vector<vector<int>> graph, vector<pair<int, int>>& colours, int m, int currentVertex){
        /** every vertex has a colour **/
	if(colours.length() == graph.length())
           return true;
        for(int vertex = 0; vertex < graph[0].size(); vertex){
	   if(graph[currentVertex][vertex] == 1){
		for(int colour = 0; colour < m + 1; colour++){
                   if(IsSafeToChooseThisColour(colour)) {
                      colours.push_back(make_pair(vertex, colour));
                      bool solutionExists = mColouringProblem(graph, colours, currentVertex);
                     /** can't colour other vertices try different colour for this vertice **/
                      if(!solutionExists)
		         colours.erase(make_pair(vertex, colour));
                      else
                         return true;
		   }
		   
	       }
             /** tried every single colour for that vertex and couldn't find the solution i.e couldn't colour the remaining 		vertices **/
             return false;
	   }
	}
       return true;
}





int findSquareRootUsinBinarySearch(int n){
 int start = 0, end = n;
 int mid = (start + mid) / 2;
 while(start <= end){
     if(mid * mid == n)
        return mid;
    else if(mid*mid > n)
          end = mid - 1;
    else
        start = mid + 1;
    mid = (start + end) / 2;    
 }
 return mid;
}

double getFloatingPoints(int n, int p, double temp){
    double factor = 1;
    for(int precision = 0; precision < p; precision++){
        factor /= 10;
        for(double ans = temp; ans * ans <= n; ans += factor){
            temp = ans;
        }
    }
    return temp;
}


void combinationalSum(vector<vector<int>>& ans, int X, vector<int> output, vector<int> elements, int currentIndex){
  if(X == 0)){
        ans.push_back(output);
        return;
  }
  // if sum of elements is greater than X, as we are subtracting so we need to check against 0
  if(X < 0)
     return;
  for(int index = currentIndex; index < elements.size(); index++){
     output.push_back(elements[index])
     combinationalSum(ans,X - elements[index],output, elements,int currentIndex);
     output.pop_back();
  }
}

/** sort the input str, then the result sets will be in ascending order**/ 
void powerSetInLexoGraphicalOrder(vector<string>& ans, string str, string output,int currentIndex) {
  if(ans.find(output) == ans.end()){
    ans.push_back(output);
    return;
  }
  for(int index = currentIndex; index < str.length; index++) {
      output.push_back(str[currentIndex]);
      powerSetInLexoGraphicalOrder(ans, str, output, currentIndex + 1);
      output.pop_back();
  }
}

/** A string S is called a sum-string if the rightmost substring can be written as the sum of two substrings before it and the same is recursively true for substrings before it. **/
bool checkIfStringIsSumString(string str){
  for(int index = str.length() - 1; index > 1; index--){
      int charactersOntheRight = 1;
      int charatersOnTheLeft = (index - characters) + 1;
      while(charactersOntheRight <= charatersOnTheLeft)) {
         checkIfSumIsFormed(, str.substr((charactersOntheRight))
         charatersOnTheLeft -= 1;
         charactersOntheRight += 1;
    }
  }
}


void kSubSetsIntoEqualSum(vector<vector<int>>& ans, vector<int>& output, vector<int> elements,int K,bool visited[], int currentIndex){
     if(elements.size() < K || (accumulate(elements.begin(),elements.end(), 0) % K != 0))
       return;
     if(K == 1){
	ans.push_back(elements);
        return;
     }
    if(accumulate(output.begin(), output.end(), 0) == accumulate(elements.begin(),elements.end(), 0) / K){
	ans.push_back(output);
        return;
    }
    /* mark current element as taken */ 
    visited[currentIndex] = true;
    output.push_back(elements[currentIndex]);
    for(int index = currentIndex + 1; index < elements.size(); index ++){
        if(!visited[index]){
           visited[index] = true;
           output.push_back(elements[index]);
           kSubSetsIntoEqualSum(ans, output,elements,K,visited,currentIndex + 1);
           output.pop_back();
           visited[index] = false
       }
    }
    output.pop_back();
}

vector<int> shortestPathInUndirectedGrapgh(vector<pair<int, int>> edges,int size, int source, int destination){
    bool visited[size];
    int parent[size];
    unordered_map<int, list<int>> adjList;
    for(int index = 0; index < size; size++){
       int u = edges[index].first;
       int v = edges[index].second;
       adjList[u].push_back(v);
       adjList[v].push_back(u); // as it is for undirected graph
   }
   if(adjList.find(source) == adjList.end() || adjList.find(destination) == adjList.end())
      return {};
   queue<int> bfsQueue;
   bfsQueue.push(source);
   while(bfsQueue.empty()) {
     int current = bfsQueue.front();
     bfsQueue.pop();
     if(current == source)
        parent[current] = -1;
     visited[current] = 1;
     for (auto const& neighbour : aadjList[current]){
         visited[neighbour] = 1;
         parent = current;
         bfsQueue.push(neighbour)
    }
  }
  vector<int> path;
  int currentNode = destination; // assuming source is 0 and destination 8, i.e 0 based indexing
  while(currentNode != source){
   path.push_back(currentNode);
   currentNode = parent[currentNode];
 }
 path.push_back(currentNode); // push source node at last or we can push destination at first
 reverse(path.begin(), path.end());
 return path
}


bool checkIfBST(Node* root){
  if(root == NULL)
     return true;
  if(root->left && root->right == NULL && root->key < root->left->key)
      return false;
  if(root->right && root->left == NULL && root->key > root->right->key)
      return false;
  if(root->right && root->left && root->left->key > root->key > root->right->key)
     return false;
  return checkIfBST(root->left) && checkIfBST(root->right);
}

// Shortest distance between two nodes in BST
int distanceFromRoot(struct Node* root, int x)
{
    if (root->key == x)
        return 0;
    else if (root->key > x)
        return 1 + distanceFromRoot(root->left, x);
    return 1 + distanceFromRoot(root->right, x);
}
 
// Returns minimum distance between a and b.
// This function assumes that a and b exist
// in BST.
int distanceBetween2(struct Node* root, int a, int b)
{
    if (!root)
        return 0;
 
    // Both keys lie in left
    if (root->key > a && root->key > b)
        return distanceBetween2(root->left, a, b);
 
    // Both keys lie in right
    if (root->key < a && root->key < b) // same path
        return distanceBetween2(root->right, a, b);
 
    // Lie in opposite directions (Root is
    // LCA of two nodes)
    if (root->key >= a && root->key <= b)
        return distanceFromRoot(root, a) +
               distanceFromRoot(root, b);
}

// Check if each internal node of a BST has exactly one child
Input: pre[] = {20, 10, 11, 13, 12}
Output: Yes
In Preorder traversal, descendants (or Preorder successors) of every node appear after the node. In the above example, 20 is the first node in preorder and all descendants of 20 appear after it. All descendants of 20 are smaller than it. For 10, all descendants are greater than it. In general, we can say, if all internal nodes have only one child in a BST, then all the descendants of every node are either smaller or larger than the node. The reason is simple, since the tree is BST and every node has only one child, all descendants of a node will either be on left side or right side, means all descendants will either be smaller or greater.

// Inorder Tree Traversal without recursion and without stack! using Morris Traversal

// Find median of BST
find inorder traversal of the BST
If number of nodes are even: then median = ((n/2th node + ((n)/2th+1) node) /2 
If number of nodes are odd: then median = (n+1)/2th node

// Print BST keys in given Range low-high, Print all the keys in increasing order.
perform inroder traversal on the BST
while performing inorder traversal check
if(low < root->key < high)

void inorder
     if no root
        return
     if(low < root->key < high)
        cout << root->key << endl;
     inorder(root->left)
     inorder(root->right)

// triplet whose sum is equal to given value 
start from index = 0 and use 2 pointer approach
Then fix two pointers, one at i + 1 and the other at n – 1. And look at the sum, 
If the sum is smaller than the required sum, increment the first pointer.
Else, If the sum is bigger, Decrease the end pointer to reduce the sum.
Else, if the sum of elements at two-pointer is equal to given sum then print the triplet and break.

// Find if there is a triplet in a Balanced BST that adds to zero
store inorder traversal of the BST in vector
we'll use same approach here except we'll check if value at index - sum(value at firstpointer + value at secondpointer)

int heightOfBST(Node* root)
   if !root
       return 0
   return 1 + max(heightBST(root->left), heightBST(root->right))

int numberOfnodesInBST(Node* root)
   if !root
       return 0;
   return 1 + numberOfnodesInBST(root->left) + numberOfnodesInBST(root->right)

// Largest BST in a Binary Tree
for every node check if it is a binary search tree
if so count the number of nodes, and update the max value
return the max value

int largestBST(Node* root)
  if !root
     return 0;
  int totalNodes = INT_MIN
  if(checkIfBST(root))
     totalNodes = max(totalNodes, numberOfnodesInBST(root))
  else
    int maxFromLeft = largestBST(root->left)
    int maxFromRight = largestBST(root->right)
    totalNodes = max(totalNodes, maxFromLeft, maxFromRight)
  return totalNodes

// Add all greater values to every node in a given BST
find and store inorder traversal in a vector
then do inorder, preorder or postorder traversal
then find sum of index+1 till end in the inorder traversal vector and add that to the current value, since inorder always gives us sorted result, so every value from current index to the right will be greater than it
to perform above pass in current node->key as the param, and then find its index and then return sum of every value after that
continue doing inorder, preorder or postorder traversal

or simple recursive approach
use a sum param and recur for right subtrees then for left subtree and as we go above in the tree keep updating sum and add value into root

void AddAllGreaterValue(Node* root,int& sum)
  if !root
     return
  AddAllGreaterValue(root->right,sum)
  sum += root->data
  root->data = sum
  AddAllGreaterValue(root->left,sum)

// The tree is AVL when the differences between the heights of left and right subtrees for every node are less than or equal to 1.

// Sorted Linked List/inorder traversal to Balanced BST, since the array is already sorted
1) Get the Middle of the linked list and make it root.
2) Recursively do same for the left half and right half.
       a) Get the middle of the left half and make it left child of the root
          created in step 1.
       b) Get the middle of right half and make it the right child of the
          root created in step 1.

Node* LLToBST(int start,int end, vector<int> sorted_array)
     if(start > end)
       return NULL
     int middleElementIndex = (start + end)/2
     Node* root = new Node(sorted_array[middleElementIndex])
     root->left = LLToBST(start,middleElementIndex-1,sorted_array)
     root->right = LLToBST(middleElementIndex+1,end,sorted_array)
     return root;

// Two nodes of a BST are swapped, correct the BST
first sort the above array, and then follow the same approach as LLToBST

// For matrix chain multiplication
we can generate all permutations recursively and then update the min value accordingly
for example - if we have dimensions of 4 matrices we can multiply them in the followig way A(BCD), (AB)(CD), (ABC)D
and then return the minimum result
later we can also convert that to dp top down/memoization or bottom up/tabulation 

// travelling salesman problem 
we can use dp to solve this problem by firstly recursively choosing every other city and then updating the min time value, as greedy solution doesn't necessarily always gives us a best solution

// pre-fill dp[] with -1 to make it as not yet solved
int travellingSalesmanProblem(int timeFromOneCity2Another[][], int currentCity, int endCity, int totalTimeTravelled,int& dp[]){
   if(currenCity == endCity)
     return totalTimeTravelled
   if(dp[currentCity] != -1)
      return dp[currentCity]
   int minTime = INT_MAX
   // perform hamiltonian cycle
   for(int nextCity = currenCity+1; current < totalCities; current++)
       int timeIfITravelledThroughThisCity = travellingSalesmanProblem(timeFromOneCity2Another,nextCity,endCity,totalTimeTravelled + timeFromOneCity2Another[currentCity][nextCity])
       minTime = min(minTime, timeIfITravelledThroughThisCity)
     return dp[currentCity] = minTime;
}

Or find out all hamiltonian paths that have hamiltonian cycle and then find the one with the minimum cost 
https://www.geeksforgeeks.org/print-all-hamiltonian-cycles-in-an-undirected-graph/?ref=rp
Create an auxiliary array, say path[] to store the order of traversal of nodes and a boolean array visited[] to keep track of vertices included in the current path.
Initially, add the source vertex (in this case ‘0’) to the path.
Now, recursively add vertices to path one by one to find the cycle.
Before adding a vertex to path, check whether the vertex being considered is adjacent to the previously added vertex or not and is not already in path. If such a vertex is found, then add it to the path and mark its value as true in the visited[] array.
If the length of path becomes equal to N, and there is an edge from the last vertex in path to 0, then print the path array.

void hamiltonianCycles(int timeFromOneCity2Another[][], int currentCity, int endCity,vector<int>& path, vector<vector<int>>& hamiltonianPaths,int totalNodes,int& costForThisPath){
   if(path.size() == totalNodes && timeFromOneCity2Another[currentCity][endCity])
      hamiltonianPaths.push_back(costForThisPath)
      return;
   for(int neighbour = 0; neighbour < totalNodes; neighbour++){
        // next city is not included and has en edge from this city
	if(path.find(neighbour) == path.end() && timeFromOneCity2Another[currentCity][neighbour] != 0)
           path.push_back(neighbour)
           costForThisPath += timeFromOneCity2Another[currentCity][neighbour]
           hamiltonianCycles(timeFromOneCity2Another[][], neighbour, endCity,path,hamiltonianPaths,totalNodes, costForThisPath)
           costForThisPath -= timeFromOneCity2Another[currentCity][neighbour]
           path.pop_back()
        else
          continue;
  }
  return
}

the above will find all the hamiltonian paths with cycle, and next just do this
int minpath = INT_MAX
for(auto &costs: hamiltonianPaths)
    minpath = min(minpath, costs)


// Ford-Fulkerson Algorithm for Maximum Flow Problem
https://www.geeksforgeeks.org/ford-fulkerson-algorithm-for-maximum-flow-problem/
capacity - max items that can flow between node1 -> node2
flow - current flow between node1 -> node2
residual capacity - capacity - flow or remaining capacity
source - starting node
sink - end node
practical use case is to find out max packets that can flow between 2 servers in a network given capacity between each hop/network

follow steps to find max flow
1. find path from source to sink
2. while travelling a path keep updating the parent array, to keep track of path
3. find the edge with minimum flow/weight
4. add that to max flow
5. update the vector<vector<int>> residualCapacity from 3 for the path found in 1, such that add value from 3 to residual[node][parent], and subtract value from 3 from residual[parent][node]

keep repeating steps 1-5 for all the paths, we can use BFS for this purpose, or backtracking but with only one condition extra apart from checking whether or not the vertex is already included or not, residual[vertex][neighbour] > 0
if(neighbour is not included in the path && residual[vertex][neighbour] > 0)
   add neighbour to path
   parent[neighbour] = vertex // use parent array only for BFS, as for backtracking we are already tracking all the paths

void FordFulkerson(vector<vector<int>>& residualCapacity, int source, int sink, vector<int>& path,int& maxFlow){
       if(source == sink)
          int maxFlowForThisPath = findEdgeWithMinimumWeight(path, residualCapacity, sink)
          maxFlow += maxFlowForThisPath
          updateResidualCapacityFromPath(path, residualCapacity,maxFlowForThisPath, sink)
          return;
       int maxFlow = 0;
       for(int neighbour = 0; neighbour < totalVertices; neighbour++){
          if(path.find(neighbour) == path.end() && residual[source][neighbour] > 0)
             path.push_back(neighbour)
             FordFulkerson(residualCapacity, neighbour, sink, path, maxFlow)
             path.push_back()
       }
       return;
}

int updateResidualCapacityFromPath(path, residualCapacity, maxFlowForThisPath,int source, int sink){
    // we're tracking same way as we do with the parent array and updating residual capacity
    int source = path[0]
    path.erase(path.begin())
    int neighbour;
    while(source != sink)
        neighbour = path[0]
        residual[source][neighbour] -= maxFlowForThisPath
        residual[neighbour][source] += maxFlowForThisPath 
        source = neighbour
        path.erase(path.begin())
    
}

int findEdgeWithMinimumWeight(path, residualCapacity, int sink){
    int MinimumWeight = INT_MAX;
    int source = path[0]
    path.erase(path.begin())
    int neighbour;
    while(source != sink)
        neighbour = path[0]
        MinimumWeight = min(MinimumWeight, residualCapacity[source][neighbour])
        source = neighbour
        path.erase(path.begin())
    return MinimumWeight
}

int FindMaxFlowUsingFordFulkerson(vector<vector<int>>& residualCapacity, int source, int sink){
     vector<int> path
     int maxFlow = 0
     FordFulkerson(residualCapacity, source, sink, path, maxFlow)
     return maxFlow
}


// Floyd Warshall Algorithm | The problem is to find the shortest distances between every pair of vertices in a given edge-weighted directed Graph. 
if (dist[i][k] + dist[k][j] < dist[i][j])
     dist[i][j] = dist[i][k] + dist[k][j];

// A balanced binary tree is one in which for every node, the difference between heights of left and right subtree is not more than 1.

Height of tree, h = 1 + max(left height, right height)
Since the difference between the heights of left and right subtree is not more than one, possible heights of left and right part can be one of the following: 
h - height f overall tree including root node
(h-1), (h-2) left  subtree is greater than one
(h-2), (h-1) right subtree is greater than one
(h-1), (h-1) both have same height
Given a height h, count and return the maximum number of balanced binary trees possible with height h
// recurrence relation for the above
count(h) = count(h-1) * count(h-2) + count(h-2) * count(h-1) + count(h-1) * count(h-1)
         = 2 * count(h-1) * count(h-2) + count(h-1) * count(h-1)
         = count(h-1) * (2*count(h - 2) + count(h - 1))
 base case - // One tree is possible with height 0 or 1
   if (h == 0 || h == 1)
        return 1;


// Convert array into Zig-Zag fashion
arr[0] < arr[1]  > arr[2] < arr[3] > arr[4] < . . . . arr[n-2] < arr[n-1] > arr[n]. 
Input: N = 7 , arr[] = {4, 3, 7, 8, 6, 2, 1} 
Output: arr[] = {3, 7, 4, 8, 2, 6, 1}
Sort the array.
Traverse the array from index 1 to N-1, and increase the value of index by 2.
While traversing the array swap arr[i] with arr[i+1].
Print the final array.

// Sort an array of 0s, 1s and 2s in O(N) time complexity and O(1) space, without using in-built sorting algorithms/functions
we can use 3 variables zeroCount, oneCount, twoCount
in first iteration we'll count how many number of each elements we have 
then in second iteration we update elements in place based on their counts starting with zeroCount,oneCount, twoCount
for(int index = 0; index < zeroCount; index++)
    arr[index] = 0

for(int index = zeroCount; index < oneCount; index++)
    arr[index] = 1


for(int index = oneCount; index < twoCount; index++)
    arr[index] = 2

// Given an array A of n positive numbers. The task is to find the first Equilibrium Point in an array. 
Equilibrium Point in an array is a position such that the sum of elements before it is equal to the sum of elements after it.
Expected Time Complexity: O(n)
Expected Auxiliary Space: O(1)

initialize 2 variables sum = sum(arr.begin(), arr.end()), leftsum = 0
iterate from 0 - N-1, and perform following operation
sum -= arr[index], leftsum += arr[index]
if(sum == leftsum) then return index;

// Maximum of all subarrays of size k
Expected Time Complexity: O(N)
Expected Auxiliary Space: O(k)
This method uses Deque to solve the above problem
Deque is a hybrid data structure serving the purpose of both the stack and queue and insertion and deletion of elements can take place from both the ends
-- use brute force solution for simplicity O(N*K)

// Transform a BST to greater sum tree
Traverse node by node(Inorder) 
For each node find all the nodes greater than that of the current node, sum the values. Store all these sums. 
Replace each node value with their corresponding sum

// Smallest window in a string containing all the characters of another string
Given two strings S and P. Find the smallest window in the string S consisting of all the characters(including duplicates) of the string P.  Return "-1" in case there is no such window present. In case there are multiple such windows of same length, return the one with the least starting index.
Input:
S = "timetopractice"
P = "toc"
Output: "toprac"
Explanation: "toprac" is the smallest
substring in which "toc" can be found.
Expected Time Complexity: O(|S|)
Expected Auxiliary Space: O(1)
brute force solution - generate all substrings and check if it has all the characters of P, find the smallest substring, O(N*N)
// for each substring call below 
bool exists(string s, string p,int s1, int s2)
  if(s2 == p.length) -- whole pattern is matched
    return true;
  if(s1 > s.length() && s2 < p.length()) -- checked the whole string but couldn't found pattern
     return false;
  if(s[s1] == p[s2])
     return exists(s,p,s1+1,s2+1);
  return exists(s,p,s1+1,s2);

for O(N) and O(1) space complexity solution we'll use hashing  + sliding window approach (https://practice.geeksforgeeks.org/problems/smallest-window-in-a-string-containing-all-the-characters-of-another-string-1587115621/1?page=1&company[]=Amazon&company[]=Microsoft&company[]=Google&company[]=Facebook&category[]=Binary%20Search%20Tree&category[]=Prime%20Number&category[]=DFS&category[]=Backtracking&category[]=two-pointer-algorithm&category[]=BFS&category[]=sliding-window&category[]=pattern-printing&curated[]=1&sortBy=submissions)

First check if the length of the string is less than the length of the given pattern, if yes then "no such window can exist ".
Store the occurrence of characters of the given pattern in a hash_pat[].
we will be using two pointer technique basically
Start matching the characters of pattern with the characters of string i.e. increment count if a character matches.
Check if (count == length of pattern ) this means a window is found.
If such a window found, try to minimize it by removing extra characters from the beginning of the current window.
delete one character from first and again find this deleted key at right, once found apply step 5 .
Update min_length.
Print the minimum length window.

string findSubString(string str, string pat)
{
    int len1 = str.length();
    int len2 = pat.length();
    if (len1 < len2) {
        cout << "No such window exists";
        return "";
    }

    int hash_pat[256] = { 0 }; // 256-including special characters
    int hash_str[256] = { 0 }; // 256-including special characters

    // Store occurrence ofs characters of pattern
    for (int i = 0; i < len2; i++)
        hash_pat[pat[i]]++;

    int start = 0, start_index = -1, min_len = INT_MAX;
    int count = 0; // Count of characters
    
    // Start traversing the string
    for (int j = 0; j < len1; j++) {
      
        // Count occurrence of characters 
        // of string
        hash_str[str[j]]++;

        // If string's char matches with 
        // pattern's char
        // then increment count
        if (hash_str[str[j]] <= hash_pat[str[j]]) // for ex - in patt we've 2 occurences of char 't' and we've matched all the 't' in str, then we've matched one character successfully
            count++;

        // if all the characters are matched
        if (count == len2) {
          
            // Try to minimize the window 
            while (hash_str[str[start]] > hash_pat[str[start]] || hash_pat[str[start]] == 0) {
                if (hash_str[str[start]] > hash_pat[str[start]])
                    hash_str[str[start]]--;
                start++;
            }

            // update window size
            int len_window = j - start + 1;
            if (min_len > len_window) {
                min_len = len_window;
                start_index = start;
            }
        }
    }

    return start_index == -1 ? "No such window exists" : str.substr(start_index, min_len);
}


// for 2, 3 sum problems we utilize same terminology of hashing, 
find the pair of elements of sum is equal to 16
then for every element in an array initialize hash_map[num[index]] = 1 
then iterate over again and subtract current index value from sum and check if hash_map[num[index]] == 1 
O(N) solution
for 3 sum store sum of pairs in hash_map[sum(i,j)] = 1
then iterate over again and subtract current index value from sum and check if hash_map[sum(i,j)] == 1 
O(N^2) solution

// Generate IP Addresses
function genIp() which returns a vector containing all possible combinations of valid IPv4 IP addresses and takes only a string S as its only argument.
Note: Order doesn't matter. A valid IP address must be in the form of A.B.C.D, where A, B, C, and D are numbers from 0-255. The numbers cannot be 0 prefixed unless they are 0.

we can use backtracking for the above, but for O(N*3) solution,
use three variables firstDot, SecondDot, ThirdDot - which represents the dots in an ipv4 address
then get 4 substrings from (0,firstDot), (firstDot, SecondDot), (SecondDot,thirdDot), (thirdDot, n)
and for each of the substrings check if the the number is between 0-255 inclusive
if so concat all of them and push them into the answer
for(int firstDot = 1; firstDot < n; firstDot++)
   for(int secondDot = firstDot+1; secondDot < n; secondDot++)
       for(int thirdDot = secondDot+1; thirdDot < n; thirdDot++)
            checkifnumberbetween0and255((0,firstDot), (firstDot, SecondDot), (SecondDot,thirdDot), (thirdDot, n))
                 res.push_back(concat((0,firstDot), (firstDot, SecondDot), (SecondDot,thirdDot), (thirdDot, n))))


// Word Boggle
Given a dictionary of distinct words and an M x N board where every cell has one character. Find all possible words from the dictionary that can be formed by a sequence of adjacent characters on the board. We can move to any of 8 adjacent characters

Note: While forming a word we can move to any of the 8 adjacent cells. A cell can be used only once in one word.
bool dfs(vector<vector<char> >& board, string &s, int i, int j, int n, int m, int idx){
       
       if(i<0 || i>=n||j<0||j>=m){
           return false;
       }
       
       if(s[idx]!= board[i][j]){
           return false;
       }
       if(idx == s.size()-1){
           return true;
       }
       
       char temp = board[i][j]; // we can use visited array to keep track of cells visited and later unvisit them rather than replacing current character
       board[i][j]='*';
       
       bool a = dfs(board,s,i,j+1,n,m,idx+1);
       bool b= dfs(board,s,i,j-1,n,m,idx+1);
       bool c = dfs(board,s,i+1,j,n,m,idx+1);
       bool d = dfs(board,s,i-1,j,n,m,idx+1);
       bool e = dfs(board,s,i+1,j+1,n,m,idx+1);
       bool f = dfs(board,s,i-1,j+1,n,m,idx+1);
       bool g = dfs(board,s,i+1,j-1,n,m,idx+1);
       bool h = dfs(board,s,i-1,j-1,n,m,idx+1);
       
       board[i][j]=temp;
       return a||b||c||e||f||g||h||d;

https://www.geeksforgeeks.org/boggle-using-trie/

// trie Node
struct TrieNode {
    TrieNode* Child[SIZE]; // SIZE - 26
    // isLeaf is true if the node represents end of a word
    bool leaf;
};
  
// Returns new trie node (initialized to NULLs)
TrieNode* getNode()
{
    TrieNode* newNode = new TrieNode;
    newNode->leaf = false;
    for (int i = 0; i < SIZE; i++)
        newNode->Child[i] = NULL;
    return newNode;
}
  
// If not present, inserts a key into the trie
// If the key is a prefix of trie node, just
// marks leaf node
void insert(TrieNode* root, char* Key)
{
    int n = strlen(Key);
    TrieNode* pChild = root;
  
    for (int i = 0; i < n; i++) {
        int index = char_int(Key[i]);
  
        if (pChild->Child[index] == NULL)
            pChild->Child[index] = getNode();
  
        pChild = pChild->Child[index];
    }
  
    // make last node as leaf node
    pChild->leaf = true;
}

// Detect Loop in linked list (for distinct elements)
use hashmap and store counts of element if while traversing the linked list count becomes greater than 1 or that element already
exists in hashmap means there's a loop

// Array to BST
first sort the array
Node* A2BST(int start, int end, int arr[]){
  if(start > end)
     return null;
  int mid = start + end / 2
  Node* root = arr[mid]
  root->left = A2BST(start, mid-1, arr)
  root->right = A2BST(mid+1, end, arr)
  return root;
}

// https://www.geeksforgeeks.org/median-of-stream-of-integers-running-integers/
// https://www.geeksforgeeks.org/minimum-length-unsorted-subarray-sorting-which-makes-the-complete-array-sorted/
// https://www.geeksforgeeks.org/median-of-stream-of-running-integers-using-stl/
// https://www.geeksforgeeks.org/k-largestor-smallest-elements-in-an-array/ - insert all the elements into min_heap if they're not sorted then keep on removing until kth element, if already sorted the no need to use min_heap
       
// when we pass a param by reference we change its value throughout all recursive call, but when we don't wanna change its value for ex - for choose unchoose we can simply pass in by value

Let's say we solving a permutation/combination problem where we have to generate all the permutations the way we do it is by choosing current character and unchoosing that character if we pass a value by reference we'll do it like this

void fn(string str, string& comb)
 comb.push_back(str[i])
 fn(str, comb)
 comb.pop_back()

but if we remove reference 
void fn(string str, string comb)
 fn(str, comb + str[i])
then in the next recursive call it'll remove it itself, we can do same thing with the int values where we have to add then subtract 
values based on the scenarios 

// Maximum width of a Binary Tree
we can solve this using level order traversal using a queue and each time we push new elements to the queue we update the max_width value
while(!queue.empty())
  if(queue.size() > max_width)
    max_width = queue.size()
  // push elements of next level
  for(int el = 0; el < queue.size(); el++)
     current_element = queue.front()
     queue.pop()
     if(curre_element->left)
       queue.push(current_element->left)
     if(curre_element->right)
       queue.push(current_element->right)

// Find the first non-repeating character from a stream of characters
Given a stream of characters, find the first non-repeating character from the stream. You need to tell the first non-repeating character in O(1) time at any moment.
https://www.geeksforgeeks.org/find-first-non-repeating-character-stream-characters/
solution discussed in above approach uses DLL, whilst we can utilize same solution and instead of DLL can use a vector

1.Create vector<int> no_repeat
Following are steps to process a new character ‘x’ in a stream - 
2.If x is present in the vector, remove it
3. if first time add it to the vector

// Number of subarrays having product less than K
for O(N) solution use sliding window technique, i.e shift leftIndex to the right until product becomes less than K, and increment the count
for(int leftIndex = 0;int rightIndex = 0; rightIndex < n;rightIndex++)
    product *= arr[rightIndex] // product of array until index rightIndex
    while(lefIndex < rightIndex && product >= k)
          product /= arr[leftIndex] // keep reducing the product by moving lefIndex
    if(product < k)
      total_subarrays++


// To handle overflow when multiplying 2 relatively large numbers 
if (a > max_int64 / b) then "overflow" else "ok".
if (b > 0 && a > 18446744073709551615 / b) {
     // overflow handling
}; else {
    c = a * b;
}

// when shifting number to the right >> it becomes number*2, and when shifted towards left it becomes number / 2
// The XOR(^) operation (or exclusive or) takes two bits and returns 1 if exactly one of the bits is 1. Otherwise, it returns 0.


// Find the closest pair from two sorted arrays in O(n) time
1) Initialize a variable diff as infinite (Diff is used to store the 
   difference between pair and x).  We need to find the minimum diff.
2) Initialize two index variables l and r in the given sorted array.
       (a) Initialize first to the leftmost index in ar1:  l = 0
       (b) Initialize second  the rightmost index in ar2:  r = n-1
3) Loop while  l< length.ar1 and r>=0
       (a) If  abs(ar1[l] + ar2[r] - sum) < diff  then 
           update diff and result 
       (b) If (ar1[l] + ar2[r] <  sum )  then l++
       (c) Else r--    
4) Print the result. 

// Check if a given graph is tree or not
An undirected graph is a tree if it has the following properties. 
There is no cycle. - using dfs O(V + E) For performing the DFS traversal
The graph is connected. - using dfs O(V + E) For performing the DFS traversal + O(V) For storing the visited array


// the difference between MAC address and IP address
The physical address -- which is also called a media access control, or MAC, address -- identifies a device to other devices on the same local network. The internet address -- or IP address -- identifies the device globally. A network packet needs both addresses to get to its destination.

// Maximum length of a substring required to be flipped repeatedly to make all characters of binary string equal to 0

// Count Possible Decodings of a given Digit Sequence
1) If the last digit is non-zero, recur for the remaining (n-1) digits and add the result to the total count. 
2) If the last two digits form a valid character (or smaller than 27), recur for remaining (n-2) digits and add the result to the total count.

Memoization
int count_d(int digits[], int n,int dp[])
    if (n == 0 || n == 1)
        return 1;
    if (digits[0] == '0') // no char has int value of 0
        return 0;
    if(dp[n] != -1)
       return dp[n]
    int count = 0;
    // If the last digit is not 0, then last digit must add to the number of words
    if (digits[n - 1] > '0')
        count = countDecoding(digits, n - 1, dp);
 
    // If the last two digits form a number smaller than or equal to 26, then consider last two digits and recur
    if (digits[n - 2] == '1' || (digits[n - 2] == '2' && digits[n - 1] < '7'))
        count += countDecoding(digits, n - 2, dp);
    return dp[n] = count

Tabulation
int count_d(int digits[], int n = sizeof(digits))
  int dp[n] // as we wanna return result at n
  dp[0] = dp[1] = 1;
  if (digits[0] == '0') 
      return 0;
  // as we've already processed n = 0 and n = 1
  for(int index = 2; index < n+1; index++ )
      if (digits[index - 1] > '0')
          dp[index] = dp[index- 1];
      if (digits[index - 2] == '1' || (digits[index - 2] == '2' && digits[index - 1] < '7'))
          dp[index] += dp[n - 2];
  return dp[n];

// Delete Edge to minimize subtree sum difference

// Minimum steps to reach target by a Knight | Set 1
we can solve this problem using bactracking and getting the minimum from all the directions
This problem can be seen as the shortest path in an unweighted graph. Therefore we use BFS to solve this problem. 
We try all 8 possible positions where a Knight can reach from its position. If the reachable position is not already visited and is inside the board, we push this state into the queue with a distance 1 more than its parent state. Finally, we return the distance of the target position, when it gets pop out from the queue

// Next Greater Element (NGE) for every element in given Array for sorted and unsorted
this can be solved using std::upper_bound for every element or using stack if don't wanna use in-built
std::lower_bound - returns iterator to first element in the given range which is EQUAL_TO or Greater than val.
std::upper_bound - returns iterator to first element in the given range which is Greater than val.

add 0th element into the stack
for index = 1 to n-1
    while !stack.empty() and stack.top() < a[index]
      cout << stack.top() << a[index]
      stack.pop()
    stack.push(a[index])
In the end we'll have elements that don't have any greater element on the right so 
while !stack.empty()
    cout << stack.top() << -1
    stack.pop()

// Find the missing and repeating number
we can do this for element from 1 to n and using std::count() > 1 and std::find() != vector.end()

// Rearrange an array in maximum minimum form using Two Pointer Technique
Input: arr[] = {1, 2, 3, 4, 5, 6, 7} 
Output: arr[] = {7, 1, 6, 2, 5, 3, 4}
Input: arr[] = {1, 2, 3, 4, 5, 6} 
Output: arr[] = {6, 1, 5, 2, 4, 3}
 
use two variables leftIndex = 0 and rightIndex = n-1
while(leftIndex < rightIndex)
    new_vector.push_back(old_vector[rightIndex])
    new_vector.push_back(old_vector[leftIndex])
    leftIndex++
    rightIndex--
new_vector.push_back(old_vector[rightIndex or leftIndex as they ar same])

// Find a pair of elements swapping which makes sum of two arrays same
find sum or array_one and array_two
calculate the difference or their sum if(array_one > array_two) diff = array_one - array_two else opposite
divide this diff / 2 as we wanna make both sums equal
sort both the arrays and use index1 and index2
calculate the difference arr[index1]-arr[index] as arr_diff
if(arr_diff < diff)
   index1++
else
  index2++
but if we found that arr_diff == diff, we need to swap index1 and index2 hence return arr[index1] and arr[index2]
if no such index1 and index2 is found return -1

// Rabin-Karp Algorithm for Pattern Searching, Given a text txt[0. . .n-1] and a pattern pat[0. . .m-1], write a function search(char pat[], char txt[]) that prints all occurrences of pat[] in txt[]. You may assume that n > m.
Input:  txt[] = “THIS IS A TEST TEXT”, pat[] = “TEST”
Output: Pattern found at index 10

Input:  txt[] =  “AABAACAADAABAABA”, pat[] =  “AABA”
Output: Pattern found at index 0
              Pattern found at index 9
              Pattern found at index 12

it uses a custom hash function to generate hashcode for the pattern and substrings int string of lenght(pattern) and if the hascode matches it does a comparison by comparing each element of substring with pattern in O(m) time, the whole idea behind this algorithm is to reduce number of comparisons, if we don't use this algorithm we'll have to compare each substring with the pattern O(n-m+1), but here we'll only do it when the hashcode of the substring matches with that of pattern, also matching hashcode doesn't gaurantee the match, as different substrings can have same hashcode for ex pattern_h = 123(aaa), substr_1 = 123(aaa) substr_2 = 123(abc), here substr_1 will match but not the substr_2, it all depends on our hash function to generate unique hashcodes to avoid as many collisions as we could

vector<int> matched_indexes
pattern_h = compute_hash(pattern)
substr_h = compute_hash(str.substr(0,length(pattern)))
if(pattern_h == substr_h)
   compareEachChar(substr, patttern)
   matched_indexes.push_back(0)
for(int index = 1; index < n-length(pattern); index++)
    /** RABIN KARP HASH FUNCTION **/
    substr_h -= total_characters*10^2 // here total_Character can varry from 26 - 256 depending on whether string and pattern contains special characters
    substr *= 10
    substr_h += str.charAt(index + length(pattern))
    /** RABIN KARP HASH FUNCTION **/
    if(pattern_h == substr_h)
       compareEachChar(substr, patttern)
       matched_indexes.push_back(0)
return matched_indexes

(https://stackoverflow.com/questions/17016175/c-unordered-map-using-a-custom-class-type-as-the-key)

// KMP - To find all occurences of pattern in string, Longest prefix which is also suffix
we can find Longest prefix which is also suffix in O(n^2)
for(int length = 0; length < n; length++)
 matched_ = true;
 prefix_ = str.substr(0, length)
 suffix_ = str.substr(str.length() - length - 1, length)
 for(int index = 0; index < length; index++)
     if(prefix_[index] != suffix_[index])
        matched_ = false;
        break;
  if(matched_)
     max_lenght = max(max_lenght, length)

But with KMP we can find Longest prefix which is also suffix in O(n)
use kmp_[N]
kmp_[0] = 0
start from index = 1
compare current index with the previous one
if there's match kmp_[currentIndex_] = kmp_[currentIndex_ - 1] + 1
if there's not a match get max value from 0 to kmp_[currentIndex_ - 1] index and let's say we call it as max_matched_characters_before_unmatch then compare str_[max_matched_characters_before_unmatch] and str_[currentIndex_]
return kmp_[n]

KMP algorithm is O(n) in the worst case. - not accurate but rough idea of how it works
int KMP(string str)
 int N = str.length()
 int kmp[N] = {0}
 for(int index = 1; index < N; index++)
     if(str[index] == str[index-1])
        kmp[index] = kmp[index-1] + 1
     else
       max_char_match_before_unmatch = findMaxValueFromIndexToIndex(0, kmp[index-1])
       if(str[index] == str[max_char_match_before_unmatch])
          kmp[index] = max_char_match_before_unmatch + 1
  return kmp[N]

// Boundary Traversal of binary tree

void printLeaves(Node* root)
{
    if (root == nullptr)
        return;
    printLeaves(root->left);
    if (!(root->left) && !(root->right))
        cout << root->data << " ";
    printLeaves(root->right);
}

void printBoundaryLeft(Node* root)
{
    if (root == nullptr)
        return;
 
    if (root->left) {
        cout << root->data << " ";
        printBoundaryLeft(root->left);
    }
   // as the second last node could not have left child but rather right
    if (root->right) {
        cout << root->data << " ";
        printBoundaryLeft(root->right);
    }
}

void printBoundaryRight(Node* root)
{
    if (root == nullptr)
        return;
    if (root->right) {
        printBoundaryRight(root->right);
        cout << root->data << " ";
    }
    // as the second last node could not have right child but rather left
          /\
         /  \
        /   /
   if (root->left) {
        printBoundaryRight(root->left);
        cout << root->data << " ";
    }
}

 // Print all leaf nodes
    printLeaves(root->left); - left subtree
    printLeaves(root->right); - right subtree

# Merge k-sorted lists
  ListNode* mergeKLists(vector<ListNode*>& lists) {
        priority_queue<int , vector<int>> pq;
        for(auto &list: lists){
            for(auto &n: list){
                pq.push(n);
            }
        }
        Node* head, *temp = new Node(pq.top());
        pq.pop();
        temp = temp->next;
        while(!pq.empty()){
          temp = new Node(pq.top());
          pq.pop();
          temp = temp->next;   
        }
        return head;
    }

# Reverse Nodes in k-Group (https://leetcode.com/problems/reverse-nodes-in-k-group/) 
Input: head = [1,2,3,4,5], k = 2
Output: [2,1,4,3,5]
1. startNode = head 
2. get kth node, endNode = kthNode, if kthNode is not NULL
3. reverse linked List until endNode, using below ReverseLinkList(startNode* start, EndNode* end), and check while(current != end)
4. update startNode = endNode->next, follow from step 2 


# Reverse Linked list
  void ReverseLinkList(Node* head){
        Node* current = head, * prev = NULL, *next = NULL;
        while(current != null){
            next = current->next;
            current->next = prev;
            prev = current;
            current = next;
        }
        head = prev;
    }

# Creating a new LL
 Node* head
 void push(int data)
    {
        Node* temp = new Node(data);
        temp->next = head;
        head = temp;
    }

# First Missing Positive
  Given an unsorted integer array nums, return the smallest missing positive integer.You must implement an algorithm that runs in O(n) time and uses constant extra space.
 - push all the elements of array in hashset or hashmap, and get max value at the same tim
 - iterate from 1 through max value and check if hashmap or hashset contains that value O(1) lookup

# Largest Rectangle in Histogram
 - leftSmallest = 0, rightSmallest = 0, max_rec
 - iterate from 0 to n-1
 - get the index of left smallest than current and right smallest than current
 - check if((rightSmallest - leftSmallest - 1) != arr[current]), as we don't want max of square but for rectangle
      * max_rec = max(max_rec, (rightSmallest - leftSmallest - 1) * arr[current])

# Binary Tree Maximum Path Sum
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 void MaxPathSum(TreeNode* root,int& maxsum){
    if(root == null)
       return 0;
    int leftSum = MaxPathSum(root->left, maxsum)
    int rightSum = MaxPathSum(root->right, maxsum)
    // get max of 
     - root->value
     - root->val + leftSum + rightSum
     - root->val + max(leftSum, rightSum)
    int maxSumSoFar = max(max(root->value, root->val+leftSum+rightSum), root->val+max(leftSum, rightSum))
    maxsum = max(maxsum, maxSumSoFar)
    return maxSoFar;
 }

# book allocation problem (https://www.youtube.com/watch?v=YTTdLgyqOLY)
int minOfMaxAllocations(int students, vector<int> pages){
   int start = 0, end = sum(pages.begin(),pages.end()), middleElementIndex, minAlocations = INT_MAX;
    while(start < end){
      int midElement = (start+end)/2;
      if(IsPossibleSolution(midElement, students, pages)){
        minAlocations = min(minAlocations, midElement)
        end = midElement-1;
      } else{
        start = midElement+1
      }
    }
    return minAlocations;
}

bool IsPossibleSolution(int midElement, int students, vector<int> pages){
  int index = 0, sum = 0, n = pages.size(), partitionsSoFar = 1 // as we allocate atleast 1 book in the beginning;
  while(index < n){
    if((sum += pages[midElement]) < midElement){
      sum += pages[midElement]
      index++;
    } else if(partitionsSoFar > students){
      return false
    } else{
      partitionsSoFar++;
      index++:
    }
  }
  return true;
}

# median of two sorted arrays

# V.V.Important tips for coding interview
- https://hackernoon.com/14-patterns-to-ace-any-coding-interview-question-c5bb3357f6ed
- https://leetcode.com/discuss/study-guide/2004928/Amazon-LP-Questions
- https://leetcode.com/discuss/interview-question/2069641/The-Only-Lists-You-Need-For-Your-Interview-Preparation
- https://leetcode.com/discuss/study-guide/2272161/Most-Important-topics-for-Interviews-or-CS-Core-topics